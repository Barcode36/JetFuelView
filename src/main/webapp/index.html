<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="css/style.css">
    <script type="text/javascript" src="js/jquery.min.js"></script>

    <style>
        canvas {
            border: 1px solid red;
        }

    </style>
    <title>System View</title>
    <script src="js/sockjs-0.3.4.js"></script>
    <script src="js/stomp.js"></script>
    <script src="js/go-debug.js"></script>
    <link rel="stylesheet" href="css/style.css">
    <script type="text/javascript">

        var stompClient = null;

        function startView() {
            initGo();
            connectToStomp();
        }

        function initGo() {
            var $ = go.GraphObject.make;  // for conciseness in defining templates

            myDiagram =
                    $(go.Diagram, "myDiagramDiv",  // create a Diagram for the DIV HTML element
                            {
                                // position the graph in the middle of the diagram
                                initialContentAlignment: go.Spot.Center,
                            });

            // Define the appearance and behavior for Nodes:

            // First, define the shared context menu for all Nodes, Links, and Groups.

            // To simplify this code we define a function for creating a context menu button:
            function makeButton(text, action, visiblePredicate) {
                return $("ContextMenuButton",
                        $(go.TextBlock, text),
                        {click: action},
                        // don't bother with binding GraphObject.visible if there's no predicate
                        visiblePredicate ? new go.Binding("visible", "", visiblePredicate).ofObject() : {});
            }

            // a context menu is an Adornment with a bunch of buttons in them
            var partContextMenu =
                    $(go.Adornment, "Vertical",
                            makeButton("Properties",
                                    function (e, obj) {  // OBJ is this Button
                                        var contextmenu = obj.part;  // the Button is in the context menu Adornment
                                        var part = contextmenu.adornedPart;  // the adornedPart is the Part that the context menu adorns
                                        // now can do something with PART, or with its data, or with the Adornment (the context menu)
                                        if (part instanceof go.Link) alert(linkInfo(part.data));
                                        else if (part instanceof go.Group) alert(groupInfo(contextmenu));
                                        else alert(nodeInfo(part.data));
                                    })
                                    <!--,-->
                            <!--makeButton("Open admin Page",-->
                                    <!--function (e, obj) {-->
                                        <!--e.diagram.commandHandler.deleteSelection();-->
                                    <!--}, function (o) {-->
                                        <!--return true;-->
                                    <!--})-->
                    );

            function nodeInfo(d) {  // Tooltip info for a node data object
                var str = "Component: " + d.key;
                if (d.group)
                    str += "\nGroup: " + d.group;
                str += "\nType: " + d.nodeType +
                        "\nConnected Time: " + d.connectedTime +
                        "\nMessages In: " + d.messagesIn +
                        "\nMessages Out: " + d.messagesOut;

                return str;
            }

            // These nodes have text surrounded by a rounded rectangle
            // whose fill color is bound to the node data.
            // The user can drag a node by dragging its TextBlock label.
            // Dragging from the Shape will start drawing a new link.
            myDiagram.nodeTemplate =
                    $(go.Node, "Vertical",
                            new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
                            {locationSpot: go.Spot.Center},
                            $(go.Picture,
                                    // Pictures should normally have an explicit width and height.
                                    // This picture has a red background, only visible when there is no source set
                                    // or when the image is partially transparent.
                                    {
                                        margin: 1, width: 100, height: 40, background: "transparent",
                                        portId: "", cursor: "pointer"
                                    }, // the Shape is the port, not the whole Node},
                                    // Picture.source is data bound to the "source" attribute of the model data
                                    new go.Binding("source"),
                                    new go.Binding("width"),
                                    new go.Binding("height")),
                            $(go.TextBlock,
                                    {
                                        font: "bold 14px sans-serif",
                                        stroke: '#333',
                                        margin: 1
                                    },
                                    new go.Binding("text", "text").makeTwoWay()),  // the label shows the node data's text
                            { // this tooltip Adornment is shared by all nodes
                                toolTip: $(go.Adornment, "Auto",
                                        $(go.Shape, {fill: "#FFFFCC"}),
                                        $(go.TextBlock, {margin: 4},  // the tooltip shows the result of calling nodeInfo(data)
                                                new go.Binding("text", "", nodeInfo))
                                ),
                                // this context menu Adornment is shared by all nodes
                                contextMenu: partContextMenu
                            }
                    );

            // Define the appearance and behavior for Links:

            function linkInfo(d) {  // Tooltip info for a link data object
                var linkDesc = "From: " + d.from + "\nTo: " + d.to;
                if (d.secondsBehind)
                    linkDesc += "\nSecondsBehind: " + d.secondsBehind;
                if (d.type)
                    linkDesc += "\nType: " + d.type;
                return linkDesc;
            }

            // The link shape and arrowhead have their stroke brush data bound to the "color" property
            myDiagram.linkTemplate =
                    $(go.Link,
                            {toShortLength: 13,  curve: go.Link.Bezier, relinkableFrom: true, relinkableTo: true},  // allow the user to relink existing links
                            $(go.Shape,
                                    {strokeWidth: 2},
                                    new go.Binding("stroke", "color")),
                            $(go.Shape,
                                    {toArrow: "Standard", stroke: null,scale: 2},
                                    new go.Binding("fill", "color")),
                            { // this tooltip Adornment is shared by all links
                                toolTip: $(go.Adornment, "Auto",
                                        $(go.Shape, {fill: "#FFFFCC"}),
                                        $(go.TextBlock, {margin: 4},  // the tooltip shows the result of calling linkInfo(data)
                                                new go.Binding("text", "", linkInfo))
                                ),
                                // the same context menu Adornment is shared by all links
                                contextMenu: partContextMenu
                            }
                    );

            // Define the appearance and behavior for Groups:

            function groupInfo(adornment) {  // takes the tooltip or context menu, not a group node data object
                var g = adornment.adornedPart;  // get the Group that the tooltip adorns
                var mems = g.memberParts.count;
                var links = 0;
                g.memberParts.each(function (part) {
                    if (part instanceof go.Link) links++;
                });
                var nodes = mems - links;
                return "Group Name: " + g.data.key + "\nNodes: " + nodes + "\nLinks: " + links;
            }

            // Groups consist of a title in the color given by the group node data
            // above a translucent gray rectangle surrounding the member parts
            myDiagram.groupTemplate =
                    $(go.Group, "Vertical",
                            {
                                selectionObjectName: "PANEL",  // selection handle goes around shape, not label
                                ungroupable: true
                            },  // enable Ctrl-Shift-G to ungroup a selected Group
                            $(go.TextBlock,
                                    {
                                        font: "bold 19px sans-serif",
                                        isMultiline: false,  // don't allow newlines in text
                                        editable: false  // allow in-place editing by user
                                    },
                                    new go.Binding("text", "text").makeTwoWay(),
                                    new go.Binding("stroke", "color")),
                            $(go.Panel, "Auto",
                                    {name: "PANEL"},
                                    $(go.Shape, "Rectangle",  // the rectangular shape around the members
                                            {fill: "rgba(128,128,128,0.2)", stroke: "gray", strokeWidth: 3}),
                                    $(go.Placeholder, {padding: 15})  // represents where the members are
                            ),
                            { // this tooltip Adornment is shared by all groups
                                toolTip: $(go.Adornment, "Auto",
                                        $(go.Shape, {fill: "#FFFFCC"}),
                                        $(go.TextBlock, {margin: 4},
                                                // bind to tooltip, not to Group.data, to allow access to Group properties
                                                new go.Binding("text", "", groupInfo).ofObject())
                                ),
                                // the same context menu Adornment is shared by all groups
                                contextMenu: partContextMenu
                            }
                    );

            // Define the behavior for the Diagram background:

            function diagramInfo(model) {  // Tooltip info for the diagram's model
                return "System View:\nNumber of nodes: " + model.nodeDataArray.length + "\nNumber of Links: " + model.linkDataArray.length;
            }

            // provide a tooltip for the background of the Diagram, when not over any Part
            myDiagram.toolTip =
                    $(go.Adornment, "Auto",
                            $(go.Shape, {fill: "#FFFFCC"}),
                            $(go.TextBlock, {margin: 4},
                                    new go.Binding("text", "", diagramInfo))
                    );
            resetSystemViewModel();
        }

        function resetSystemViewModel() {
            var nodeDataArray = [];
            var linkDataArray = [];
            myDiagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);
        }

        function getImage(componentName) {
            var imageObject = new Object();
            var componentNameLowerCase = componentName.toLowerCase();
            if (componentNameLowerCase.indexOf("jetfuel") > -1) {
                imageObject.imageName = "images/JetFuelMediumNoBg.png";
                imageObject.imageWidth = 50;
                imageObject.imageHeight = 40;
            } else if (componentNameLowerCase.indexOf("fusion") > -1) {
                imageObject.imageName = "images/client.png";
                imageObject.imageWidth = 50;
                imageObject.imageHeight = 40;
            } else {
                imageObject.imageName = "images/component.jpg";
                imageObject.imageWidth = 35;
                imageObject.imageHeight = 40;
            }
            return imageObject;
        }

        function createClient(clientName, conType, connectTo, connectedTime, messagesIn, messagesOut) {
            var imageObject = getImage(clientName);
            var oldNode = myDiagram.model.findNodeDataForKey(clientName);
            if (oldNode === null) {
                var componentType = "Server Component";
                var componentNameLowerCase = clientName.toLowerCase();
                if (componentNameLowerCase.indexOf("client") > -1) {
                    componentType = "Client User";
                }
                myDiagram.model.addNodeData({
                    key: clientName,
                    text: clientName,
                    nodeType: componentType,
                    connectedTime: connectedTime,
                    messagesIn: messagesIn,
                    messagesOut: messagesOut,
                    source: imageObject.imageName,
                    width: imageObject.imageWidth,
                    height: imageObject.imageHeight
                });
                if (conType === "in") {
                    myDiagram.model.addLinkData({
                        from: connectTo,
                        to: clientName,
                        owner: clientName,
                        color: "blue"
                    });
                }
                else if (conType === "out") {
                    myDiagram.model.addLinkData({
                        from: clientName,
                        to: connectTo,
                        owner: clientName,
                        color: "blue"
                    });
                }
                else {
                    myDiagram.model.addLinkData({
                        from: connectTo,
                        to: clientName,
                        owner: clientName,
                        color: "blue"
                    });
                    myDiagram.model.addLinkData({
                        from: clientName,
                        to: connectTo,
                        owner: clientName,
                        color: "blue"
                    });
                }
            } else {
                // update
                var imageObject = getImage(clientName);
                myDiagram.model.setDataProperty(oldNode, 'source', imageObject.imageName);
                myDiagram.model.setDataProperty(oldNode, 'connectedTime', connectedTime);
                myDiagram.model.setDataProperty(oldNode, 'messagesIn', messagesIn);
                myDiagram.model.setDataProperty(oldNode, 'messagesOut', messagesOut);
                myDiagram.model.linkKeyProperty = 'owner';
                var link = myDiagram.model.findLinkDataForKey(clientName);
                myDiagram.model.setDataProperty(link, 'color', 'blue');
            }
        }

        function createAmpsServer(ampsServerName, groupName, replication, connectedTime, messagesIn, messagesOut) {
            var oldNode = myDiagram.model.findNodeDataForKey(ampsServerName);
            if (oldNode === null) {
                var imageObject = new Object();
                if (connectedTime.length > 1) {
                    imageObject.imageName = "images/ampsServer.png";
                }
                else{
                    imageObject.imageName = "images/ampsServerOff2.png";
                }

                imageObject.imageWidth = 100;
                imageObject.imageHeight = 40;
                myDiagram.model.addNodeData({
                    key: ampsServerName,
                    text: ampsServerName,
                    nodeType: "Amps Broker",
                    connectedTime: connectedTime,
                    messagesIn: messagesIn,
                    messagesOut: messagesOut,
                    group: groupName,
                    source: imageObject.imageName,
                    width: imageObject.imageWidth,
                    height: imageObject.imageHeight
                });

                for (var j = 0; j < replication.length; j++) {
                    myDiagram.model.addLinkData({
                        from: ampsServerName,
                        to: replication[j].name,
                        owner: ampsServerName,
                        secondsBehind: replication[j].secondsBehind,
                        type: replication[j].type,
                        color: "purple"
                    });
                }
            } else {
                //update

            }
        }

        function createAmpsGroup(groupName) {
            var oldNode = myDiagram.model.findNodeDataForKey(groupName);
            if (oldNode === null) {
                myDiagram.model.addNodeData({key: groupName, text: groupName, color: "green", isGroup: true});
            }
        }

        function redrawSystemView(json) {
            resetSystemViewModel();
            var objectData = JSON.parse(json);
            var groupsArray = [];
            for (var i = 0; i < objectData.servers.length; i++) {
                var ampsServerName = objectData.servers[i].name;
                var groupName = objectData.servers[i].group;
                var connectedTime = objectData.servers[i].connectedTime;
                var messagesIn = objectData.servers[i].messagesIn;
                var messagesOut = objectData.servers[i].messagesOut;
                for (var a = 0; a < objectData.servers[i].clients.length; a++) {
                    createClient(objectData.servers[i].clients[a].name,
                            objectData.servers[i].clients[a].type.toLowerCase(),
                            ampsServerName,
                            objectData.servers[i].clients[a].connectedTime,
                            objectData.servers[i].clients[a].messagesIn,
                            objectData.servers[i].clients[a].messagesOut);
                }
                if (groupName != null) {
                    if (groupsArray.indexOf(groupName) == -1) {
                        groupsArray.push(groupName);
                    }
                    createAmpsServer(ampsServerName, groupName, objectData.servers[i].replication, connectedTime, messagesIn, messagesOut);
                }
            }
            for (var i = 0; i < groupsArray.length; i++) {
                createAmpsGroup(groupsArray[i])
            }

            for (var i = 0; i < objectData.unknownServers.length; i++) {
                    var unknownServer = objectData.unknownServers[i];
                    var imageObject = new Object();
                    imageObject.imageName = "images/ampsServerOff.png";
                    imageObject.imageWidth = 100;
                    imageObject.imageHeight = 40;
                    myDiagram.model.addNodeData({
                        key: unknownServer,
                        text: 'Unreachable ' + unknownServer,
                        source: imageObject.imageName,
                        width: imageObject.imageWidth,
                        height: imageObject.imageHeight
                    });
              }
              updateMessage("Diagram updated from server. ");
        }

        function processSystemViewUpdates(message) {
            var objectData = JSON.parse(message);
            if (objectData.updatedClients != null) {
                for (var i = 0; i < objectData.updatedClients.length; i++) {
                    createClient(objectData.updatedClients[i].name,
                            objectData.updatedClients[i].type.toLowerCase(),
                            objectData.updatedClients[i].ampsServer,
                            objectData.updatedClients[i].connectedTime,
                            objectData.updatedClients[i].messagesIn,
                            objectData.updatedClients[i].messagesOut
                    );
                }
            }
            if (objectData.deletedClients != null) {
                for (var i = 0; i < objectData.deletedClients.length; i++) {
                    myDiagram.model.linkKeyProperty = 'owner';
                    var node = myDiagram.model.findNodeDataForKey(objectData.deletedClients[i].name);
                    var link = myDiagram.model.findLinkDataForKey(objectData.deletedClients[i].name);
                    var oldSource = node.source;
                    var newSource = 'images/componentOff.jpg';
                    if (oldSource.indexOf('client') > 0) {
                        newSource = 'images/clientOff.png';
                    }
                    myDiagram.model.setDataProperty(node, 'source', newSource);
                    myDiagram.model.setDataProperty(link, 'color', 'grey');
                }
            }
        }

        function disconnect() {
            if (stompClient != null) {
                stompClient.disconnect();
            }
            console.log("Disconnected");
        }

        function connectToStomp() {
            var socket = new SockJS('/jetfuel');
            stompClient = Stomp.over(socket);
            stompClient.connect({}, function (frame) {
                console.log('Connected: ' + frame);
                 updateMessage("Connected");
                loadSavedView();
                 updateMessage("Loaded saved config. ");
                subscribeToSytemViewUpdates();
            });
        }

        function subscribeToSytemViewUpdates() {
            stompClient.subscribe('/topic/systemDiagramViewUpdateFeed', function (updates) {
                var message = JSON.parse(updates.body).content;
                processSystemViewUpdates(message);
            });
            stompClient.send("/app/systemDiagramViewUpdateCmd", {}, JSON.stringify({'env': 'env'}));
        }

        function showGreeting(message) {
            <!--var response = document.getElementById('subResponse');-->
            <!--var p = document.createElement('p');-->
            <!--p.appendChild(document.createTextNode(message));-->
            <!--response.appendChild(p);-->
        }

        function updateMessage(message) {
            document.getElementById("statusPanel").innerHTML = message + new Date();
        }

        function save() {
            var jsonToSave = myDiagram.model.toJson();
            <!--document.getElementById("mySavedModel").value = jsonToSave;-->
            stompClient.subscribe('/topic/systemViewModelSaveReply', function (greeting) {
                showGreeting(JSON.parse(greeting.body).content);
            });
            stompClient.send("/app/systemViewModelSaveCmd", {}, jsonToSave);
            updateMessage("Diagram Saved. ");
        }

        function add() {
            var imageObject = new Object();
            imageObject.imageName = "images/ampsServer.png";
            imageObject.imageWidth = 100;
            imageObject.imageHeight = 40;
            myDiagram.model.addNodeData({
                key: 'Deepsk1',
                text: 'Deepsk1',
                group: 'Dee',
                source: imageObject.imageName,
                width: imageObject.imageWidth,
                height: imageObject.imageHeight
            });

            myDiagram.model.addLinkData({
                from: 'Deepsk1',
                to: 'Deepsk21',
                owner: 'Deepsk1',
                color: "purple"
            });
        }

        function update() {
            var oldDate = myDiagram.model.findNodeDataForKey('LDN_PRIMARY');
            myDiagram.model.setKeyForNodeData(oldDate, 'Newwwwwwwww');
            myDiagram.model.setDataProperty(oldDate, 'text', 'Newwwwwwwww');
        }

        function removeNode() {
            myDiagram.model.linkKeyProperty = 'owner';
            var node = myDiagram.model.findNodeDataForKey('Deepsk');
            var link = myDiagram.model.findLinkDataForKey('Deepsk');
            myDiagram.model.removeLinkData(link);
            myDiagram.model.removeNodeData(node);
        }

        function loadSavedView() {
            resetSystemViewModel();
            stompClient.subscribe('/topic/systemViewModelGetReply', function (modelData) {
                var message = JSON.parse(modelData.body).content;
                if (message.length > 1) {
                    <!--document.getElementById("mySavedModel").value = message;-->
                    myDiagram.model = go.Model.fromJson(message);
                } else {
                    getCurrentSystemView();
                }
                stompClient.unsubscribe('/topic/systemViewModelGetReply');
            });
            stompClient.send("/app/systemViewModelGetCmd", {}, JSON.stringify({'env': 'env'}));
        }

        function getCurrentSystemView() {
            //unsubscribe to udpates
            stompClient.unsubscribe('/topic/systemDiagramViewUpdateFeed');
            //get systemview
            stompClient.subscribe('/topic/systemDiagramViewGetFeed', function (greeting) {
                var message = JSON.parse(greeting.body).content;
                showGreeting(message);
                redrawSystemView(message);
                stompClient.unsubscribe('/topic/systemDiagramViewGetFeed');
            });
            stompClient.send("/app/systemDiagramViewGetCmd", {}, JSON.stringify({'env': 'env'}));
            //subscribe to updates
            subscribeToSytemViewUpdates();
        }


    </script>
</head>
<body onload="startView()" onbeforeunload="disconnect()">
<center><h1>JetFuelView - Showing all Amps servers only</h1>
    <button id="SaveButton" onclick="save()">Save</button>
    <!--<button onclick="add()">add</button>-->
    <!--<button onclick="addnoLink()">addnolink</button>-->
    <!--<button onclick="removeNode()">remove</button>-->
    <button id="updateView" onclick="getCurrentSystemView()">Force Update View from Server</button>
    <div>
        <p id="statusPanel"></p>
    </div>
</center>
<div id="myDiagramDiv" style="border: solid 1px black; width:1300px; height:720px"></div>


</body>
</html>